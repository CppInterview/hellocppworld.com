## # 第二章 变量和基本类型

## 2.1 基本内置类型

`C++`定义了一套包括**算术类型**（`arithmetic type`）和**空类型**（`void`）在内的基本数据类型。其中算术类型包含了字符、整形数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊场合，如不反悔任何值时使用空类型作为返回类型。

### 2.2.1 算术类型

算术类型分为两类：**整形**和**浮点型**。

算术类型的大小在不同机器上有所差别，`C++`只标准只对不同类型的最小值做了约束，并未规定各个类型的准确大小，具体大小看各个编译器的实现。

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    std::cout << "long size = " << sizeof(long) << std::endl;
    return 0;
}
```

这段代码在`msvc`编译执行的结果和在`gcc`下编译执行的结果完全不同。说明两家编译器厂商对于`long`的实现时完全不同的。

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8位          |
| short       | 短整型         | 16位         |
| int         | 整形           | 16位         |
| long        | 长整形         | 32位         |
| long long   | 长整型         | 64位         |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

当然，**C++**除了支持基本字符类型`char`外，还支持扩展字符类型如`wchar_t`、`char16_t`、`char32_t`、`wchar_t`等用于支持国际化。

大部分编译器以`4`字节和`8`字节大小实现`float`和`double`，具体实现可参考`IEEE 754`。

**带符号类型和无符号类型**

除去布尔型和扩展的字符型之外，其他的整形都可以划分为**带符号**（`signed`）和**无符号**（`unsigned`）两种。一般无符号类型的范围为`0 - 2^n-1`，而带符号的范围为`-2^(n-1) - 2^(n-1)-1`。欲知详情，请参考关键字`原码`、`反码`、`补码`。

值得注意的是，`char`类型有三种，分别是`char`、`signed char`和`unsigned char`，但表现出来的只有两种。`char`最终会被表现为`signed char`或u`nsigned char`，如何表现要看编译器的实现。

### 2.1.2 类型转换

类型转换是将对象从一种给定的类型转换为另一种类型。我们需要记住一下规则：

* 当一个非布尔类型的算术值赋给（转换成）布尔类型时，算术值为`0`时为`false`，否则为`true`。
* 当把一个布尔值赋给非布尔值时，初始值为`false`则结果为`0`，否则结果为1。
* 当把浮点数赋给整数类型时，将浮点数中的小数部分去除，保留了浮点数中的整数部分。
* 当把一个整数赋给浮点数时，浮点部分记0，整数部分保留。（整数部分未超过浮点数容量）
* 当我们赋给一个无符号类型一个超出它范围的值时，结果会被取模。
* 当我们赋给一个有符号类型一个超出它范围的值时，结果是**未定义**的。（`undefined behavior`）

**未定义的行为在C++中是一个巨大的黑洞，任何靠近它的东西都是极度危险的。最好的结果是在当前编译器上正好能够得到理想的结果，而一旦移植到其他平台将产生无法预测且稀奇古怪的错误。记住，在你的C++编程生涯中，一定要对未定义的行为避而远之！**

**含有无符号类型的表达式**

不要把无符号类型和有符号类型一起运算。

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    unsigned int i = 10;
    int j = -42;
    
    std::cout << i + j << std::endl;
    return 0;
}
```

这段程序将输出什么？这取决于编译器对`int`的实现，但是相信我，不会输出`32`！原因在于，编译器在执行`unsign` + `signed`的时，把`signed`隐式转换位`unsigned`，而负数转换为无符号，结果是对负数对`2^n-1`取模。所以结果取决于编译器实现`int`时使用了多少位。

尽量不要使用无符号数作为`for`循环的条件。

```cpp
#include <iostream?
int main(int argc, char* argv[])
{
    for(unsigned i = 10; i >=0; i--)
    {
        std::cout << "Hello Cpp World!" << std::endl;
    }
    
    return 0;
}
```

以上代码会一直循环下去，而不会只循环`10`次，其中原因，在于`i >=0` 永远成立。



## 2.2 变量

## 2.3 符合类型

## 2.4 const限定符

## 2..5 处理类型

## 2.6 自定义数据结构