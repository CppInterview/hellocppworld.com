## # 第二章 变量和基本类型

## 2.1 基本内置类型

`C++`定义了一套包括**算术类型**（`arithmetic type`）和**空类型**（`void`）在内的基本数据类型。其中算术类型包含了字符、整形数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊场合，如不反悔任何值时使用空类型作为返回类型。

### 2.2.1 算术类型

算术类型分为两类：**整形**和**浮点型**。

算术类型的大小在不同机器上有所差别，`C++`只标准只对不同类型的最小值做了约束，并未规定各个类型的准确大小，具体大小看各个编译器的实现。

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    std::cout << "long size = " << sizeof(long) << std::endl;
    return 0;
}
```

这段代码在`msvc`编译执行的结果和在`gcc`下编译执行的结果完全不同。说明两家编译器厂商对于`long`的实现时完全不同的。

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8位          |
| short       | 短整型         | 16位         |
| int         | 整形           | 16位         |
| long        | 长整形         | 32位         |
| long long   | 长整型         | 64位         |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

当然，**C++**除了支持基本字符类型`char`外，还支持扩展字符类型如`wchar_t`、`char16_t`、`char32_t`、`wchar_t`等用于支持国际化。

大部分编译器以`4`字节和`8`字节大小实现`float`和`double`，具体实现可参考`IEEE 754`。

**带符号类型和无符号类型**

除去布尔型和扩展的字符型之外，其他的整形都可以划分为**带符号**（`signed`）和**无符号**（`unsigned`）两种。一般无符号类型的范围为`0 - 2^n-1`，而带符号的范围为`-2^(n-1) - 2^(n-1)-1`。欲知详情，请参考关键字`原码`、`反码`、`补码`。

值得注意的是，`char`类型有三种，分别是`char`、`signed char`和`unsigned char`，但表现出来的只有两种。`char`最终会被表现为`signed char`或u`nsigned char`，如何表现要看编译器的实现。

### 2.1.2 类型转换

类型转换是将对象从一种给定的类型转换为另一种类型。我们需要记住一下规则：

* 当一个非布尔类型的算术值赋给（转换成）布尔类型时，算术值为`0`时为`false`，否则为`true`。
* 当把一个布尔值赋给非布尔值时，初始值为`false`则结果为`0`，否则结果为1。
* 当把浮点数赋给整数类型时，将浮点数中的小数部分去除，保留了浮点数中的整数部分。
* 当把一个整数赋给浮点数时，浮点部分记0，整数部分保留。（整数部分未超过浮点数容量）
* 当我们赋给一个无符号类型一个超出它范围的值时，结果会被取模。
* 当我们赋给一个有符号类型一个超出它范围的值时，结果是**未定义**的。（`undefined behavior`）

**未定义的行为在C++中是一个巨大的黑洞，任何靠近它的东西都是极度危险的。最好的结果是在当前编译器上正好能够得到理想的结果，而一旦移植到其他平台将产生无法预测且稀奇古怪的错误。记住，在你的C++编程生涯中，一定要对未定义的行为避而远之！**

**含有无符号类型的表达式**

不要把无符号类型和有符号类型一起运算。

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    unsigned int i = 10;
    int j = -42;
    
    std::cout << i + j << std::endl;
    return 0;
}
```

这段程序将输出什么？这取决于编译器对`int`的实现，但是相信我，不会输出`32`！原因在于，编译器在执行`unsign` + `signed`的时，把`signed`隐式转换位`unsigned`，而负数转换为无符号，结果是对负数对`2^n-1`取模。所以结果取决于编译器实现`int`时使用了多少位。

尽量不要使用无符号数作为`for`循环的条件。

```cpp
#include <iostream?
int main(int argc, char* argv[])
{
    for(unsigned i = 10; i >=0; i--)
    {
        std::cout << "Hello Cpp World!" << std::endl;
    }
    
    return 0;
}
```

以上代码会一直循环下去，而不会只循环`10`次，其中原因，在于`i >=0` 永远成立。

### 2.1.3 字面值常量

一个如`42`的值被称为**字面值常量**（`literal`）。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

**整形和浮点型字面值**

可以把整形字面值写作十进制数、八进制数或十六进制数。

以`0`开头的为八进制，以`0x`或`0X`开头的是十六进制。

```cpp
20  //十进制
024 //八进制
0x14 //十六进制
```

默认情况下，十进制字面值是带符号数，取`int`、`long`、`long long`中能容得下字面值的最小尺寸的那个。

默认情况下， 八进制和十六进制既可能是带符号的也可能是不带符号的，选取能够容纳其值的`int`、`unsigned int`、`long`、 `unsigned long`、`long long`、和`unsigned long long`中尺寸最小的那个。

如果一个字面量与之关联的最大的数据类型都放不下，将产生错误。

浮点型字面量表现为一个小数或以科学计数法表示的指数，其中指数部分用`E`或`e`表示：

 ```cpp
 3.14159 3.14.19e0 0. 0E0 .001
 ```

**字符和字符串字面量**

```cpp
'a' 	//字符字面量
 "Hello Cpp World!"	//字符串字面量
```

编译器会在每个字符串的结尾加一个空字符（`\0`），因此字符串字面量的实际长度要比它的内容多`1`。

**转义序列**

有两类字符不能直接使用：一类是不可打印的字符（如退格或其他控制字符），另一类是C++语言中有特殊含义的字符（如单引号，双引号，问号、反斜线）。

这些情况下需要用到**转义序列**（`escape sequence`），转义序列均以反斜线作为开始，C++语言规定的转义序列包括：

| 换行符 \n     | **横向制表符  \t** | 响铃符 \a  |
| ------------- | ------------------ | ---------- |
| 纵向制表符 \v | 退格符 \b          | 双引号 \ " |
| 反斜杠 \ \    | 问号 \?            | 单引号 \ ' |
| 回车符 \r     | 进制符 \f          |            |

一般使用最多的是`\n`，主要用于`C`风格代码中换行。

**指定字面值的类型**

字符和字符串一般指定前缀：

| 前缀 | 含义            | 类型     |
| ---- | --------------- | -------- |
| u    | Unicode 16 字符 | char16_t |
| U    | Unicode 32字符  | char32_t |
| L    | 宽字符          | wchat_t  |
| u8   | UTF-8           | char     |

整形和浮点型字面值一般指定后缀：

| 后缀           | 最小类型（类型） |
| -------------- | ---------------- |
| u或U           | unsigned         |
| l或L           | long             |
| ll或LL         | long long        |
| f或F           | float            |
| l或L（带小数） | long double      |

一般带小数或者`e`的字面量直接解析为`double`。

## 2.2 变量

变量提供一个具名的、可供程序操作的存储空间。

`C++`中的每个变量都有其数据类型，数据类型决定变量所占内存的大小和布局方式，该空间能够存储的值的范围，以及变量能够参与的运算。

对于`C++`程序员来说，变量（`variable`）和对象（`object`）一般可以互换使用。

### 2.2.1 变量定义



## 2.3 符合类型

## 2.4 const限定符

## 2..5 处理类型

## 2.6 自定义数据结构