## # 第二章 变量和基本类型

## 2.1 基本内置类型

`C++`定义了一套包括**算术类型**（`arithmetic type`）和**空类型**（`void`）在内的基本数据类型。其中算术类型包含了字符、整形数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊场合，如不反悔任何值时使用空类型作为返回类型。

### 2.2.1 算术类型

算术类型分为两类：**整形**和**浮点型**。

算术类型的大小在不同机器上有所差别，`C++`只标准只对不同类型的最小值做了约束，并未规定各个类型的准确大小，具体大小看各个编译器的实现。

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    std::cout << "long size = " << sizeof(long) << std::endl;
    return 0;
}
```

这段代码在`msvc`编译执行的结果和在`gcc`下编译执行的结果完全不同。说明两家编译器厂商对于`long`的实现时完全不同的。

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8位          |
| short       | 短整型         | 16位         |
| int         | 整形           | 16位         |
| long        | 长整形         | 32位         |
| long long   | 长整型         | 64位         |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

当然，**C++**除了支持基本字符类型`char`外，还支持扩展字符类型如`wchar_t`、`char16_t`、`char32_t`、`wchar_t`等用于支持国际化。

大部分编译器以`4`字节和`8`字节大小实现`float`和`double`，具体实现可参考`IEEE 754`。

**带符号类型和无符号类型**

除去布尔型和扩展的字符型之外，其他的整形都可以划分为**带符号**（`signed`）和**无符号**（`unsigned`）两种。一般无符号类型的范围为`0 - 2^n-1`，而带符号的范围为`-2^(n-1) - 2^(n-1)-1`。欲知详情，请参考关键字`原码`、`反码`、`补码`。

值得注意的是，`char`类型有三种，分别是`char`、`signed char`和`unsigned char`，但表现出来的只有两种。`char`最终会被表现为`signed char`或u`nsigned char`，如何表现要看编译器的实现。

### 2.1.2 类型转换

类型转换是将对象从一种给定的类型转换为另一种类型。我们需要记住一下规则：

* 当一个非布尔类型的算术值赋给（转换成）布尔类型时，算术值为`0`时为`false`，否则为`true`。
* 当把一个布尔值赋给非布尔值时，初始值为`false`则结果为`0`，否则结果为1。
* 当把浮点数赋给整数类型时，将浮点数中的小数部分去除，保留了浮点数中的整数部分。
* 当把一个整数赋给浮点数时，浮点部分记0，整数部分保留。（整数部分未超过浮点数容量）
* 当我们赋给一个无符号类型一个超出它范围的值时，结果会被取模。
* 当我们赋给一个有符号类型一个超出它范围的值时，结果是**未定义**的。（`undefined behavior`）

**未定义的行为在C++中是一个巨大的黑洞，任何靠近它的东西都是极度危险的。最好的结果是在当前编译器上正好能够得到理想的结果，而一旦移植到其他平台将产生无法预测且稀奇古怪的错误。记住，在你的C++编程生涯中，一定要对未定义的行为避而远之！**

**含有无符号类型的表达式**

不要把无符号类型和有符号类型一起运算。

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    unsigned int i = 10;
    int j = -42;
    
    std::cout << i + j << std::endl;
    return 0;
}
```

这段程序将输出什么？这取决于编译器对`int`的实现，但是相信我，不会输出`32`！原因在于，编译器在执行`unsign` + `signed`的时，把`signed`隐式转换位`unsigned`，而负数转换为无符号，结果是对负数对`2^n-1`取模。所以结果取决于编译器实现`int`时使用了多少位。

尽量不要使用无符号数作为`for`循环的条件。

```cpp
#include <iostream?
int main(int argc, char* argv[])
{
    for(unsigned i = 10; i >=0; i--)
    {
        std::cout << "Hello Cpp World!" << std::endl;
    }
    
    return 0;
}
```

以上代码会一直循环下去，而不会只循环`10`次，其中原因，在于`i >=0` 永远成立。

### 2.1.3 字面值常量

一个如`42`的值被称为**字面值常量**（`literal`）。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

**整形和浮点型字面值**

可以把整形字面值写作十进制数、八进制数或十六进制数。

以`0`开头的为八进制，以`0x`或`0X`开头的是十六进制。

```cpp
20  //十进制
024 //八进制
0x14 //十六进制
```

默认情况下，十进制字面值是带符号数，取`int`、`long`、`long long`中能容得下字面值的最小尺寸的那个。

默认情况下， 八进制和十六进制既可能是带符号的也可能是不带符号的，选取能够容纳其值的`int`、`unsigned int`、`long`、 `unsigned long`、`long long`、和`unsigned long long`中尺寸最小的那个。

如果一个字面量与之关联的最大的数据类型都放不下，将产生错误。

浮点型字面量表现为一个小数或以科学计数法表示的指数，其中指数部分用`E`或`e`表示：

 ```cpp
 3.14159 3.14.19e0 0. 0E0 .001
 ```

**字符和字符串字面量**

```cpp
'a' 	//字符字面量
 "Hello Cpp World!"	//字符串字面量
```

编译器会在每个字符串的结尾加一个空字符（`\0`），因此字符串字面量的实际长度要比它的内容多`1`。

**转义序列**

有两类字符不能直接使用：一类是不可打印的字符（如退格或其他控制字符），另一类是C++语言中有特殊含义的字符（如单引号，双引号，问号、反斜线）。

这些情况下需要用到**转义序列**（`escape sequence`），转义序列均以反斜线作为开始，C++语言规定的转义序列包括：

| 换行符 \n     | **横向制表符  \t** | 响铃符 \a  |
| ------------- | ------------------ | ---------- |
| 纵向制表符 \v | 退格符 \b          | 双引号 \ " |
| 反斜杠 \ \    | 问号 \?            | 单引号 \ ' |
| 回车符 \r     | 进制符 \f          |            |

一般使用最多的是`\n`，主要用于`C`风格代码中换行。

**指定字面值的类型**

字符和字符串一般指定前缀：

| 前缀 | 含义            | 类型     |
| ---- | --------------- | -------- |
| u    | Unicode 16 字符 | char16_t |
| U    | Unicode 32字符  | char32_t |
| L    | 宽字符          | wchat_t  |
| u8   | UTF-8           | char     |

整形和浮点型字面值一般指定后缀：

| 后缀           | 最小类型（类型） |
| -------------- | ---------------- |
| u或U           | unsigned         |
| l或L           | long             |
| ll或LL         | long long        |
| f或F           | float            |
| l或L（带小数） | long double      |

一般带小数或者`e`的字面量直接解析为`double`。

## 2.2 变量

变量提供一个具名的、可供程序操作的存储空间。

`C++`中的每个变量都有其数据类型，数据类型决定变量所占内存的大小和布局方式，该空间能够存储的值的范围，以及变量能够参与的运算。

对于`C++`程序员来说，变量（`variable`）和对象（`object`）一般可以互换使用。

### 2.2.1 变量定义

首先是**类型说明符**（`type specifier`），后面紧跟一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。定义变量时可以为其赋初值。

```CPP
int i, j = 0, sum = 42;
std::string str("Hello Cpp World!");
```

**初始值**

当对象在创建时获得一个特定的值，这个对象被**初始化**（`initialzied`）了。在`C++`中，初始化时一个异常复杂的问题，我们也将反复讨论这个问题。很多程序员对于使用`=`初始化变量感到困惑，这种方式让人认为初始化时赋值的一种。实际上在`C++`中初始化和赋值是完全两种不同的概念。让我们看看看声明、定义、初始化和赋值的差别：

* 声明：告诉编译器这里有一个什么类型的变量，并不分配内存。
* 定义：告诉编译器这里有一个什么类型的变量，并未变量分配`sizeof(type)`的内存。
* 初始化：在定义变量的时候赋给变量初值的过程就是初始化。
* 赋值：擦去变量的现有值，并以新的值替代。

**列表初始化**

`C++`语言定义了初始化的好几种不同形式，这也是初始化问题复杂的一个体现。例如，如果想初始化一个`int`变量，可以使用一下`4`种方法中的任意一种：

```cpp
int i(42);
int i{42};
int i = 42;
int i = {42};
```

在`C++11`中，花括号初始化变量得到了全面应用。这种初始化的方式成为**列表初始化**（`list initialization`）。

当内置类型使用列表初始化时，如果初始值存在丢失信息的风险，则编译器会报错：

```cpp
double PI = 3.1415926;
int i(PI), j = PI;	//初始化成功，i == j == 3
int m{PI}, n = {PI}; //初始化失败
```

**默认初始化**

如果定义变量时没有指定初值，则变量被**默认初始化**（`default initialized`），此时变量被赋予默认值，默认值是什么由变量的类型和变量所在的位置决定。

* 如果变量处于函数内
  * 如果变量是内置类型，则不被初始化，变量的值是随机的
  * 如果变量是自定义类型，将执行自定义类型的默认构造函数，如果没有默认构造函数，编译器会为类生成默认构造函数
* 如果变量处于函数外（全局变量）
  * 如果变量是内置类型，将被初始化为`0`
  * 如果是自定义类型，将执行自定义类型的默认构造函数，如果没有默认构造函数，编译器会为类生成默认构造函数

建议初始化每一个内置类型的变量，不管变量在何处出现。使用未初始化的变量将会带来无法预估的后果。

### 2.2.2 变量声明和定义的关系

**C++**支持**分离式编译**（`separate compilation`）机制，允许将程序分割为若干个文件，每个文件独立编译。

为了支持分离式编译，**C++**将声明和定义区分开来。**声明**（`declaration`）使得名字为程序所知，一个文件如果想使用这个名字对应的变量必须包含对这个名字的声明。**定义**（`definition`）负责创建与名字关联的实体。

一个变量可以多次声明，但只能被定义一次。

```cpp
extern double pi;		//声明
double pi = 3.1415926;	//定义
extern double pi2 = 3.1415926;	//定义，extern语句如果包含初始值就不再是声明，而是定义
```

### 2.2.3 标识符

`C++`的**标识符**（identifier）由字母、数字、下划线组成，必须以字母或下划线开头，标识符的长度没有限制，但是对大小写字母敏感。

**C++**为标准库保留了一些名字，用户自定义的标识符不能联系出现两个下划线，也不能以下划线紧连着大写字母开头。此外，定义在函数体外的标识符也不能以下划线开头。（非强制）

**变量命名规范**

变量的命名有许多约定俗成的规范：

* 标识符要能体现出实际含义。
* 变量名一般用小写字母
* 自定义类名一般以大写字母开头
* 如果标识符有多个单词组成，单词间应该有明显区分，如`hello_cpp_world`或`helloCppWorld`，而不要使用`hellocppworld`。

坚持命名规范，做一个受人尊敬的程序员！

|            |              | C++关键字 |                  |          |
| ---------- | ------------ | :-------: | ---------------- | -------- |
| alignas    | cntinue      |  friend   | register         | true     |
| alignof    | decltype     |   goto    | reinterpret_cast | try      |
| asm        | defealt      |    if     | return           | typedef  |
| auto       | dekete       |  inline   | short            | typeid   |
| bool       | do           |    int    | signed           | typename |
| break      | double       |   long    | sizeof           | union    |
| case       | dynamic_cast |  mutable  | static           | unsigned |
| catch      | else         | namespace | static_assert    | using    |
| char       | enum         |    new    | static_cast      | virtual  |
| char16_t   | explict      | noexpect  | struct           | void     |
| char32_t   | export       |  nullptr  | switch           | volatile |
| class      | extern       | operator  | tempalte         | wchar_t  |
| const      | false        |  private  | this             | while    |
| constexpr  | float        | protected | thread_local     |          |
| const_cast | for          |  public   | throw            |          |

### 2.24 名字的作用域

**作用域**（`scope`）是程序的一部分，`C++`中大多数的作用域都已花括号分割。

同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

```cpp
#include <iostream>
int g = 256;	//全局作用域，程序开始的时候生效，程序结束的时候失效
int main(int argc, char* argv[])
{
    int i = 42;	//i作用域开始
    {
        int j = 1024;	//j作用域开始
        std::cout << g << std::endl;	//正确，g在此位置有效
        std::cout << i << std::endl;	//正确，i在此位置有效
    	std::cout << j << std::endl;	//正确，j在此位置无效
    }// j作用域结束
    std::cout << g << std::endl;	//正确，g在此位置有效
    std::cout << i << std::endl;	//正确，i在此位置有效
    std::cout << j << std::endl;	//错误，j在此位置无效
    return 0;
}// i作用域结束
```

在函数体体之外定义的名字拥**有全局作用域**（`global scope`），全局作用域内的名字在整个程序的范围内都可以使用。在函数内部定义的名称拥有**块作用域**（`block scope`）。块作用域只在当前块内有效，当前块结束后名称就不在生效。

**嵌套的作用域**

作用域能包含作用域，被包含的作用域称为**内层作用域**（`inner scope`），包含着别的作用域的作用域称为**外层作用域**（`outer scope`）。

在外层作用域定义的名字，在内层作用域中可以使用，反之则不行。

在外层作用域定义的名字，如果在内层作用域内重新定义，则内层作用域中内，名字所表示的为内层作用域所定义的对象，而在外层作用域中，名字所表示的为外层作用域所定义的对象。

```CPP
#include <iostream>

int main(int argc, char* argv[])
{
    int i = 42;
    {
        double i = 3.14;
        std::cout << i << std::endl;	// 3.14
	}
    std::cout << i << std::endl;	//42
    return 0;
}
```

如果在内层作用域中重新定义了全局作用域的名字，可以在内层作用域中使用`::变量名`表示全局作用域中的内容。

```cpp
#include <iostream>
int i = 42;
int main(int argc, char* argv[])
{
    double i = 3.14;
    std::cout << i << std::endl;	//3.14
    std::cout << ::i << std::endl;	//42
    return 0;
}
```

虽然可以在内层作用域中覆盖外层作用域和全局作用域的名称，但是实际开发中极少使用这种方式定义变量。

## 2.3 复合类型

**复合类型**（`compound type`）是指基于其他类型定义的类型。

### 2.3.1 引用

**引用**（`reference`）为对象起了另外一个名字，引用类型引用（`refer to`）另外一种类型。通过将声明符写成`&d`的形式来定义引用类型，其中`d`是声明的变量名：

```cpp
int i = 42;
int& ri = i;
int& r;		//错误，引用必须初始化
```

一般在初始化变量时，初始值会被拷贝到新建对象中。而定义引用时，程序把引用和它的初始值**绑定**（`bind`）在一起，而不是将初始值拷贝给引用。

一旦初始化完成，引用和它的初始值对象一直绑定在一起。因为引用重新绑定到另外一个对象，因此引用必须初始化。

**引用即别名**

引用并非对象，它只是为一个已经存在的对象所起的另外一个名字。

引用本身并不是一个对象，所以不能定义引用的引用。除此之外，对引用的所有操作，等同于对原对象的操作。

**引用的定义**

允许在一条语句中定义多个引用，

```cpp
int i = 1024;
int& r1 = &i, &r2 = i;	//r1 == r2 refer to i
```

除了常量引用和右值引用，其余所有的引用的类型要和原对象类型严格匹配，且只能绑定在对象上，而不能与字面值或某个表达式的计算结果（返回右值）绑定在一起。

```cpp
int i = 1024;
int& ri = i;
int& r = 42;	//错误
const int& ci = 42;	//正确，常量引用
int&& ri = 42;	//正确，右值引用
```

### 2.3.2  指针

**指针**（`pointer`）时指向（`point to`）另外一种类型的复合类型。

指针与引用的相同点：引用与指针都能实现对其他对象的间接访问。

指针与引用的不同点：

* 指针本身是一个对象，允许对指针赋值和拷贝，指针的声明周期内可以指向不同的对象。
* 指针无需再定义时赋值，如果指针没有初始化，和其他内置类型一样，指针的值是未定义的，不确定的值。

可以将声明符写成`*d`的方式来定义指针类型，其中`d`是变量名称。如果一条语句中定义了多个指针变量，每个变量前面都必须有符号`*`。

```cpp
int* p1, *p2;
double dp1,*dp2;	//dp1是double类型的变量，而dp2是double类型的指针变量
```

**获取对象的地址**

指针存放某个对象的地址，要获取该地址，需要使用**取地址符**（`&`）：

```cpp
int i = 42;
int* p = &i;	//&i取出了i变量的内存地址并赋给p
```

注意取地址符`&`和引用声明符`&`相同，如果用在类型后则为引用声明，如果用在变量前则为取地址符。初学者容易混淆二者用法。

```cpp
int i = 42;
int& ri = i;	//引用，ri是i的别名
int* pi = &i;	//取地址，把i的地址取出来赋给pi
```

除了指向常量的指针可以指向非常量对象和基类的指针可以指向子类的对象外，其他所有指针的类型都要和它指向的对象严格匹配：

```cpp
int i = 42;
const int* pi = &i;	//指向常量的指针指向非常累对象
Derived d;
Base* p = &d;	//基类的指针指向子类的对象

double* pd = &i;	//错误，指针类型要和指向的对象严格匹配
```

**指针值**

指针的值应属于下列`4`种状态之一：

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针（`nullptr`）
3. 无效指针，也就是上述情况之外的其他值

定义而不初始化一个指针，此指针就是无效指针。试图拷贝或者以其他方式访问无效指针的值将会引发错误。编译器并不负责检查此类错误，这一点和试图使用未初始化的变量是一样的。

尽管第`2`和第`3`类指针是有效的，所以试图访问此类指针指向的对象的行为不被允许。

**利用指针访问对象**

如果一个指针指向了一个对象，则允许使用**解引用符**（`*`）来访问对象。

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    int i = 42;
    int* p = &i;
    std::cout << "i = " << i << std::endl;
    std::cout << "*p = " << *p << std::endl;
    return 0;
}
```

解引用操作仅适合那些确实指向了某个对象的指针。

**空指针**

**空指针**（`null point`）不指向任何对象。试图使用一个指针之前可以先检查它是否为空。得到空指针的直接办法是使用字面值`nullptr`来初始化指针，在`C++11`之前可以使用名字为`NULL`的**预处理变量**（`preprocessor variable`）。`C++11`之后尽量使用`nullptr`代替`NULL`。

预处理变量不属于命名空间`std`，它由预处理器负责管理。因此在使用时无需加上`std::`。当使用一个预处理变量时，预处理器会自动的将它替换为实际值，因此使用`NULL`初始化指针和使用`0`初始化指针的效果时相同的。

```cpp
#inlclude <iostream>

int main(int argc, char* argv[])
{
    int i = 42;
    int* p1 = &i;
    int* p2 = nullptr;
    if(p1 != nullptr){ std::cout << *p1 << std::endl;}
    if(p2 != nullptr){ std::cout << *p2 << std::endl;}
    return 0;
}
```

和内置变量一样，未经初始化的指针所引发的错误是无法预计的。所以在定义指针是尽量初始化指针。

**赋值和指针**

指针和引用都能提供对其他对象的简介访问，然而具体实现细节上二者由很大的不同。具体来说，引用一旦绑定到对象上，就无法令其再绑定到其他对象，之后的每次赋值都是对这个对象赋值。

```cpp
int i = 42;
int j = 1024;
int& r = i;	//r绑定到i上
r = j;		//并非把r绑定到j上了，而是把j的值赋值给了i，此时i == j == 1024
```

而指针不同，指针不仅能够改变其指向的地址，还能够改变指针指向的对象的值。

```cpp
int i = 42, j = 1024;
int* p = &i;	//此时p指向i，p的值等于i的内存地址
*p = 2048;		//解引用，等同于 i = 2048；
p = &j;			//此时改变的是p的值，p指向了一个新地址
```

**其他指针操作**

可以对指针进行布尔运算，所有不等于`0`（`nullptr`）的指针都返回`true`，否则返回`false`。

对于两个类型相同的指针，可以使用相等操作符（`==`）和不相等操作符（`!=`）来比较它们，如果二者指向的地址相同，则返回`true`，否则返回`false`。

**void*指针**

`void*`是一种特殊的指针类型，它可以存放任意对象的地址。一个`void*`指针存放着一个地址，但是我们并不了解这个地址的类型，所以不能对其解引用。一般用于接口中，泛化接口接受的指针类型。

### 2.3.3 理解复合类型的声明

变量的定义包含一个基本的数据类型（`base type`）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。

```cpp
int i = 1024, *p = &i, &r = i;
```

基本数据类型是公用的，而类型修饰符修饰当前变量。

**定义多个变量**

在定义语句中，类型修饰符（`*`或`&`）只作用于当前变量，

```cpp
int* p1, p2;	//这种方法容易产生误导，让人以为int*是一种类型，p2不是一个int指针，而是一个int
int *p1, p2;	//这种方法不易产生误导，但是会有让他人不知道p1是什么类型的感觉
```

以上两种声明都是合法的，没有孰对孰错之分，选择并坚持其中的一种写法，尽量不要混用即可。（我本人偏向于第一种，推荐新手使用第一种，但不要在一行语句中定义多个变量。书中推荐第二种。）

**指向指针的指针**

因为指针是在内存中存在的对象（大小为`sizeof(void*)`），所以可以对指针取地址。对对象取到的地址为指针，对指针取到的地址为指针的指针，对指针的指针取到的地址为指针的指针的指针。

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    int i = 42;
    int* pi = &i;
    int** ppi = &pi;
    int*** pppi = &ppi;
    
    std::cout << "i = " << i << std::endl;
    std::cout << "*pi = " << *pi << std::endl;
    std::cout << "**ppi = " << **ppi << std::endl;
    std::cout << "***pppi = " << ***pppi << std::endl;
    return 0;
}
```

实际工程中一般可能会用到二重指针，三重或者三重以上的指针很少会有实际应用。

**指向指针的引用**

引用本身不是一个对象，所以不存在指向引用的指针，对引用对象取地址视为对原对象取地址：

```cpp
int i = 42; &r = i;
int& * pr = &r;	//错误，不存在指向引用的指针
int* pr = &r;	//正确，对引用取地址等同于对原对象取地址
int*& pr2 = pr;	//正确，存在指针的引用，对pr2的操作等同鱼对pr的操作
```

当面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。

## 2.4 const限定符

可以使用`const`关键字定义值不被改变的变量。

因为`const`对象一旦创建后其值不能再改变，所以`const`对象必须初始化。

**初始化和const**

对象的类型决定了其上的操作，`const`对象上能够执行不改变其内容的所有操作。

```cpp
int i = 42;
const int ci = i;
ci = 42;	//错误，试图改变const对象ci的值
int j = ci;	//正确，把const ci的值赋给了j，但并未改变ci。注意这里执行的是拷贝操作，ci的值拷贝给j在内存中开辟
		   //一块新的空间并把ci的值写入到这块空间，拷贝（赋值）完成后ci和j是两个不同的对象，只不过其值相等
```

**默认情况下，const对象尽在文件内有效**

当我们定义一个`const`对象时，

```cpp
const int bufSize = 512;	//缓冲区大小
```

因为`bufSize`的值不可改变，所有编译器在编译的过程中会把`bufSize`出现的地方替换成`512`（类似于宏，但比宏安全性更高）。

为了实现上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了`const`对象的文件都必须能够访问它的初始值才行。要做到这一点，就必须在每个用到变量的文件中都有对它的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下`const`对象被设定为仅在文件内有效。在多个文件中出现了同名的`const`变量是，其实等同于在不同文件中分别定义了独立的变量。

如果要在多个文件内使用同一个`const`变量，只需要在定义和声明的地方同时加上`extern`即可。

```cpp
//main.cpp
#include <iostream>
extern int i;
extern int j;
int main(int argc, char* argv[])
{
    std::cout << i << std::endl;
    std::cout << j << std::endl;
    return 0;
}
```

```cpp
//test.cpp
int i = 1024;
extern const int j = 2048;	//const变量需要加入exterm关键字，否则链接的时候发生错误
```

```sh
g++ main.cpp test.cpp -o test
./test	# 1024 2048
```

### 2.4.1 const的引用

可以把引用绑定到`const`对象上，就像绑定到其他对象上一样。这种引用称为**对常量的引用**（`reference to const`）。

与普通引用不同的是，不能通过常量的引用修改它所绑定的对象。

```cpp
int i = 42;
const int& r = i;
r = 1024;	//错误，不能通过常量引用改变绑定的对象的值
```

不可以把常量绑定到普通引用上，因为可以通过普通引用改变对象的值，而常量的值是不可改变的。

```cpp
const int i = 1024;
int& r = i;	//错误，r是非常量引用，可以使用r改变绑定的对象的值，但是对象是i，是常量，不能改变不能，所以不能这样绑定
```

**初始化对const的引用**

2.3.1节提到，引用的类型必须与对象的类型一致，但是有两个意外，第一个例外就是，在初始化常量引用时允许任意表达式作为初始值，只要改表达式的结果能转换成引用的类型即可。

这条规则允许一个常量引用绑定非常量的对象、字面值，甚至时表达式：

```cpp
int i = 42;
const int& r1 = i;	//正确，常量引用绑定到普通int对象
const int& r2 = 42;	//正确，r2是一个常量引用
const int& r3 = r1 * 2;	//正确，r3是一个常量引用
int& r4 = r1 * 2;	//错误，不能把右值绑定到左值引用上
```

当我们把字面值或的表达式绑定到常量引用时，编译器为字面量或表达式结果创建了一个临时量，并把常量引用绑定到这个临时量上：

```cpp
const int& r = 1024;
//等同于
int tmp = 1024;
const int& r = tmp;

//所以以下表达式时正确的
const int& r = 3.14;
//等同于
int tmp = 3.14;
const int& r = tmp;
```

**对const的引用可以引用一个并非const的对象**

常量的引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量并未做出限定，可能通过其他途径改变对象本身。

```cpp
int i = 42;
const int& ci = i;
ci = 1024;	//错误，ci是常量引用，不能通过常量引用改变变量的值
i = 1024;	//正确，可以改变变量的值，此时ci == 1024

const int i = 42;
const int& ci = i;
ci = 1024;	//错误，ci是常量引用，不能通过常量引用改变变量的值
i = 1024;	//错误，i是常量，不能改变其值
```

可以把一个常量绑定到常量引用，也可以把一个变量绑定给一个常量引用。相同点是不能通过这个常量引用改变变量的值。

### 2.4.2 指针和const

与引用一样，也可以令指针指向常量或非常量。**指向常量的指针**（`pointer to const`）不能用于改变其所指向的对象。

```cpp
const int i = 42;
const int* pi = &i;
*pi = 1024;	//错误，不能通过指向常量的指针改变对象的值
```

允许一个指向常量的指针指向一个非常量的对象：

```cpp
int i = 42;
const int* pi = &i;
*pi = 1024;	//错误，不能通过指向常量的指针改变对象的值
```

和常量引用一样，指向常量的指针也可以指向非常量对象。指向常量的指针只约束不能通过该指针改变对象的值，并没有要求这个值是常量还是非常量。

所谓指向常量的指针或引用，不过是指针或引用自以为是罢了，它们觉得自己指向了常量，所以不会通过自己改变对象的值。

**const指针**

指针是对象而引用不是。因此允许把指针本身定为常量。常量指针（`const pointer`）和其他常量对象一样，必须初始化，一旦初始化完成，它的值就不能再改变了。把`*`放在`const`之前表明指针是一个常量，常量指针约束指针本身，而不是约束指针指向的对象：

```cpp
int i = 42;
int j = 1024;
int *const p = &ci;
p = &j;		//错误，不可以改变常量指针的值
*p = 2048;	//正确，可以改变常量指针指向的值
```

### 2.4.3 顶层const

指针本身是一个对象，它又可以指向另一个对象。因此指针本身是不是常量和指向的对象是不是常量这是两个相互独立的问题。**顶层const**（`top-level const`）表示指针本身是一个常量，而**底层const**（`low-level const`）表示指针指向的对象是一个常量。

顶层`const`可以表示任意的对象是常量，而底层`const`则只能与引用和指针有关。引用类型只有底层`const`，而指针类型既有底层`const`也有顶层`const`。

```cpp
const int i = 42;	//顶层const
int j = 1024;
const int& ci = i;	//底层const
const int* pi = &i;	//底层const
int* const pi2 = &j;	//顶层const
const int* const pi3 = &i;	//既是顶层const也是底层const，不能改变指针，也不能改变指针指向的对象
```

当执行对象拷贝时，常量时顶层const还是底层const区别明显。顶层const可以忽略，而底层const不能忽略。

```cpp
const int i = 42;	//顶层const
const int* pi = &i;	//底层const

int j = i;	//正确，值的拷贝开辟了新的空间，j和i属于不同的内存空间，可以拥有不同的权限
int *pi2 = pi;	//错误，pi2和pi指向同一内存空间，不能通过pi改变变量的值，所以也不能通过pi2改变变量的值

const int* const pi3 = &i;
const int* pi4 = pi3;	//正确，顶层const可以忽略，顶层const不能忽略
```

### 2.4.4 constexpr 和常量表达式

**常量表达式**（`const expression`）是指不会改变并且编译过程就能得到计算结果的表达式。

```cpp
const int i = 42;		//i在编译器得出结果，是常量表达式
const int j = i + 1;	//j在编译器得出结果，是常量表达式
int k = 42;				//k不能在编译器得出结果，可能还有其他地方改变k的值，所以k不是常量表达式
const int m = get_size();	//m不是常量表达式
```

**const变量**







## 2..5 处理类型

## 2.6 自定义数据结构