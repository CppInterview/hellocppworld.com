# 第16章 模板与泛型编程

## 16.1 定义模板

面向对象编程（`OOP`）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：`OPP`能处理类型在程序运行之前都未知的情况；而泛型编程中，在编译时就能获知类型了。

容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛型程序时，独立于任何特定类型来编写的。当使用一个泛型程序时，提供类型或值，程序实例可在其上运行。

模板是泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者公式。当使用一个`vector`泛型类型或者`find`泛型函数时，只需要提供足够的信息，就能够将蓝图转换为特定的类或函数。这种转换发生在编译时。

### 16.1.1 函数模板

```cpp
int compare(const std::string & v1, const std::string &v2)
{
    if(v1 < v2) return -1;
    if(v2 < v1) return 1;
    return 0;
}

int compare(const std::double & v1, const std::double &v2)
{
    if(v1 < v2) return -1;
    if(v2 < v1) return 1;
    return 0;
}
```

这两个函数除了参数类型不同，其他几乎都是相同的。如果要写不同的类型相比较，多少中类型就要写多少个函数。

### 16.1.2 类模板

可以定义一个通用的**函数模板**（`function template`），而不是为每个类型都定义一个新的函数。一个函数模板就是一个公式，可以用来生成针对特定类型版函数版本。

```cpp
template<class T>
int compare(const T& v1, const T& t2)
{
    if(v1 < v2) return -1;
    if(v2 < v2) return 1;
    return 0;
}
```

模板定义以关键字`template`开始，后跟一个**模板参数列表（**`template parameter list`），这是一个逗号分隔的一个或多个**模板参数**（`template parameter`）的列表，用小于号（`<`）和大于号（`>`）包围起来。

模板参数列表的作用很像函数参数列表。函数参数列表定义了若干特定类型的局部变量，但并未指出如何初始化他们。在运行时，调用者提供实参来初始化形参。

类似的，模板参数表示类或函数定义中用到的类型或直。当使用模板时，（隐式或显式的）指定**模板实参**（`template parameter`），将其绑定到模板参数上。

**实例化函数模板**

当调用一个函数模板时，编译器通常用函数实参来为我们推断模板实参。

```cpp
std::cout << compare(1,0) << std::endl;	//T 推断为 int
```

编译器用推断出来的模板参数为我们**实例化**（`instantiate`）一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参替代对应的模板参数来创建出模板的一个新“实例”。

```cpp
```



### 16.1.3 模板参数

### 16.1.4 成员模板

### 16.1.5 控制实例化

### 16.1.6 效率和灵活性

## 16.2 模板实参推断

### 16.2.1 类型转换与模板类型参数

### 16.2.2 函数模板显式实参

### 16.2.3 尾置返回类型与类型转换

### 16.2.4 函数指针和实参推断

### 16.2.5 模板实参推断和引用

### 16.2.6 理解std::move

### 16.2.7 转发

## 16.3 重载与模板

## 16.4 可变参数模板

### 16.4.1 编写可变参数函数模板

### 16.4.2 包扩展

### 16.4.3 转发参数包

## 16.5 模板特例化



