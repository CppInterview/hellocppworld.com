## # 第二章 变量和基本类型

## 2.1 基本内置类型

`C++`定义了一套包括**算术类型**（`arithmetic type`）和**空类型**（`void`）在内的基本数据类型。其中算术类型包含了字符、整形数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊场合，如不反悔任何值时使用空类型作为返回类型。

### 2.2.1 算术类型

算术类型分为两类：**整形**和**浮点型**。

算术类型的大小在不同机器上有所差别，`C++`只标准只对不同类型的最小值做了约束，并未规定各个类型的准确大小，具体大小看各个编译器的实现。

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    std::cout << "long size = " << sizeof(long) << std::endl;
    return 0;
}
```

这段代码在`msvc`编译执行的结果和在`gcc`下编译执行的结果完全不同。说明两家编译器厂商对于`long`的实现时完全不同的。

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8位          |
| short       | 短整型         | 16位         |
| int         | 整形           | 16位         |
| long        | 长整形         | 32位         |
| long long   | 长整型         | 64位         |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

当然，**C++**除了支持基本字符类型`char`外，还支持扩展字符类型如`wchar_t`、`char16_t`、`char32_t`、`wchar_t`等用于支持国际化。

大部分编译器以`4`字节和`8`字节大小实现`float`和`double`，具体实现可参考`IEEE 754`。

**带符号类型和无符号类型**

除去布尔型和扩展的字符型之外，其他的整形都可以划分为**带符号**（`signed`）和**无符号**（`unsigned`）两种。一般无符号类型的范围为`0 - 2^n-1`，而带符号的范围为`-2^(n-1) - 2^(n-1)-1`。欲知详情，请参考关键字`原码`、`反码`、`补码`。

值得注意的是，`char`类型有三种，分别是`char`、`signed char`和`unsigned char`，但表现出来的只有两种。`char`最终会被表现为`signed char`或u`nsigned char`，如何表现要看编译器的实现。

### 2.1.2 类型转换

类型转换是将对象从一种给定的类型转换为另一种类型。我们需要记住一下规则：

* 当一个非布尔类型的算术值赋给（转换成）布尔类型时，算术值为`0`时为`false`，否则为`true`。
* 当把一个布尔值赋给非布尔值时，初始值为`false`则结果为`0`，否则结果为1。
* 当把浮点数赋给整数类型时，将浮点数中的小数部分去除，保留了浮点数中的整数部分。
* 当把一个整数赋给浮点数时，浮点部分记0，整数部分保留。（整数部分未超过浮点数容量）
* 当我们赋给一个无符号类型一个超出它范围的值时，结果会被取模。
* 当我们赋给一个有符号类型一个超出它范围的值时，结果是**未定义**的。（`undefined behavior`）

**未定义的行为在C++中是一个巨大的黑洞，任何靠近它的东西都是极度危险的。最好的结果是在当前编译器上正好能够得到理想的结果，而一旦移植到其他平台将产生无法预测且稀奇古怪的错误。记住，在你的C++编程生涯中，一定要对未定义的行为避而远之！**

**含有无符号类型的表达式**

不要把无符号类型和有符号类型一起运算。

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    unsigned int i = 10;
    int j = -42;
    
    std::cout << i + j << std::endl;
    return 0;
}
```

这段程序将输出什么？这取决于编译器对`int`的实现，但是相信我，不会输出`32`！原因在于，编译器在执行`unsign` + `signed`的时，把`signed`隐式转换位`unsigned`，而负数转换为无符号，结果是对负数对`2^n-1`取模。所以结果取决于编译器实现`int`时使用了多少位。

尽量不要使用无符号数作为`for`循环的条件。

```cpp
#include <iostream?
int main(int argc, char* argv[])
{
    for(unsigned i = 10; i >=0; i--)
    {
        std::cout << "Hello Cpp World!" << std::endl;
    }
    
    return 0;
}
```

以上代码会一直循环下去，而不会只循环`10`次，其中原因，在于`i >=0` 永远成立。

### 2.1.3 字面值常量

一个如`42`的值被称为**字面值常量**（`literal`）。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

**整形和浮点型字面值**

可以把整形字面值写作十进制数、八进制数或十六进制数。

以`0`开头的为八进制，以`0x`或`0X`开头的是十六进制。

```cpp
20  //十进制
024 //八进制
0x14 //十六进制
```

默认情况下，十进制字面值是带符号数，取`int`、`long`、`long long`中能容得下字面值的最小尺寸的那个。

默认情况下， 八进制和十六进制既可能是带符号的也可能是不带符号的，选取能够容纳其值的`int`、`unsigned int`、`long`、 `unsigned long`、`long long`、和`unsigned long long`中尺寸最小的那个。

如果一个字面量与之关联的最大的数据类型都放不下，将产生错误。

浮点型字面量表现为一个小数或以科学计数法表示的指数，其中指数部分用`E`或`e`表示：

 ```cpp
 3.14159 3.14.19e0 0. 0E0 .001
 ```

**字符和字符串字面量**

```cpp
'a' 	//字符字面量
 "Hello Cpp World!"	//字符串字面量
```

编译器会在每个字符串的结尾加一个空字符（`\0`），因此字符串字面量的实际长度要比它的内容多`1`。

**转义序列**

有两类字符不能直接使用：一类是不可打印的字符（如退格或其他控制字符），另一类是C++语言中有特殊含义的字符（如单引号，双引号，问号、反斜线）。

这些情况下需要用到**转义序列**（`escape sequence`），转义序列均以反斜线作为开始，C++语言规定的转义序列包括：

| 换行符 \n     | **横向制表符  \t** | 响铃符 \a  |
| ------------- | ------------------ | ---------- |
| 纵向制表符 \v | 退格符 \b          | 双引号 \ " |
| 反斜杠 \ \    | 问号 \?            | 单引号 \ ' |
| 回车符 \r     | 进制符 \f          |            |

一般使用最多的是`\n`，主要用于`C`风格代码中换行。

**指定字面值的类型**

字符和字符串一般指定前缀：

| 前缀 | 含义            | 类型     |
| ---- | --------------- | -------- |
| u    | Unicode 16 字符 | char16_t |
| U    | Unicode 32字符  | char32_t |
| L    | 宽字符          | wchat_t  |
| u8   | UTF-8           | char     |

整形和浮点型字面值一般指定后缀：

| 后缀           | 最小类型（类型） |
| -------------- | ---------------- |
| u或U           | unsigned         |
| l或L           | long             |
| ll或LL         | long long        |
| f或F           | float            |
| l或L（带小数） | long double      |

一般带小数或者`e`的字面量直接解析为`double`。

## 2.2 变量

变量提供一个具名的、可供程序操作的存储空间。

`C++`中的每个变量都有其数据类型，数据类型决定变量所占内存的大小和布局方式，该空间能够存储的值的范围，以及变量能够参与的运算。

对于`C++`程序员来说，变量（`variable`）和对象（`object`）一般可以互换使用。

### 2.2.1 变量定义

首先是**类型说明符**（`type specifier`），后面紧跟一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。定义变量时可以为其赋初值。

```CPP
int i, j = 0, sum = 42;
std::string str("Hello Cpp World!");
```

**初始值**

当对象在创建时获得一个特定的值，这个对象被**初始化**（`initialzied`）了。在`C++`中，初始化时一个异常复杂的问题，我们也将反复讨论这个问题。很多程序员对于使用`=`初始化变量感到困惑，这种方式让人认为初始化时赋值的一种。实际上在`C++`中初始化和赋值是完全两种不同的概念。让我们看看看声明、定义、初始化和赋值的差别：

* 声明：告诉编译器这里有一个什么类型的变量，并不分配内存。
* 定义：告诉编译器这里有一个什么类型的变量，并未变量分配`sizeof(type)`的内存。
* 初始化：在定义变量的时候赋给变量初值的过程就是初始化。
* 赋值：擦去变量的现有值，并以新的值替代。

**列表初始化**

`C++`语言定义了初始化的好几种不同形式，这也是初始化问题复杂的一个体现。例如，如果想初始化一个`int`变量，可以使用一下`4`种方法中的任意一种：

```cpp
int i(42);
int i{42};
int i = 42;
int i = {42};
```

在`C++11`中，花括号初始化变量得到了全面应用。这种初始化的方式成为**列表初始化**（`list initialization`）。

当内置类型使用列表初始化时，如果初始值存在丢失信息的风险，则编译器会报错：

```cpp
double PI = 3.1415926;
int i(PI), j = PI;	//初始化成功，i == j == 3
int m{PI}, n = {PI}; //初始化失败
```

**默认初始化**

如果定义变量时没有指定初值，则变量被**默认初始化**（`default initialized`），此时变量被赋予默认值，默认值是什么由变量的类型和变量所在的位置决定。

* 如果变量处于函数内
  * 如果变量是内置类型，则不被初始化，变量的值是随机的
  * 如果变量是自定义类型，将执行自定义类型的默认构造函数，如果没有默认构造函数，编译器会为类生成默认构造函数
* 如果变量处于函数外（全局变量）
  * 如果变量是内置类型，将被初始化为`0`
  * 如果是自定义类型，将执行自定义类型的默认构造函数，如果没有默认构造函数，编译器会为类生成默认构造函数

建议初始化每一个内置类型的变量，不管变量在何处出现。使用未初始化的变量将会带来无法预估的后果。

### 2.2.2 变量声明和定义的关系

**C++**支持**分离式编译**（`separate compilation`）机制，允许将程序分割为若干个文件，每个文件独立编译。

为了支持分离式编译，**C++**将声明和定义区分开来。**声明**（`declaration`）使得名字为程序所知，一个文件如果想使用这个名字对应的变量必须包含对这个名字的声明。**定义**（`definition`）负责创建与名字关联的实体。

一个变量可以多次声明，但只能被定义一次。

```cpp
extern double pi;		//声明
double pi = 3.1415926;	//定义
extern double pi2 = 3.1415926;	//定义，extern语句如果包含初始值就不再是声明，而是定义
```

### 2.2.3 标识符

`C++`的**标识符**（identifier）由字母、数字、下划线组成，必须以字母或下划线开头，标识符的长度没有限制，但是对大小写字母敏感。

**C++**为标准库保留了一些名字，用户自定义的标识符不能联系出现两个下划线，也不能以下划线紧连着大写字母开头。此外，定义在函数体外的标识符也不能以下划线开头。（非强制）

**变量命名规范**

变量的命名有许多约定俗成的规范：

* 标识符要能体现出实际含义。
* 变量名一般用小写字母
* 自定义类名一般以大写字母开头
* 如果标识符有多个单词组成，单词间应该有明显区分，如`hello_cpp_world`或`helloCppWorld`，而不要使用`hellocppworld`。

坚持命名规范，做一个受人尊敬的程序员！

|            |              | C++关键字 |                  |          |
| ---------- | ------------ | :-------: | ---------------- | -------- |
| alignas    | cntinue      |  friend   | register         | true     |
| alignof    | decltype     |   goto    | reinterpret_cast | try      |
| asm        | defealt      |    if     | return           | typedef  |
| auto       | dekete       |  inline   | short            | typeid   |
| bool       | do           |    int    | signed           | typename |
| break      | double       |   long    | sizeof           | union    |
| case       | dynamic_cast |  mutable  | static           | unsigned |
| catch      | else         | namespace | static_assert    | using    |
| char       | enum         |    new    | static_cast      | virtual  |
| char16_t   | explict      | noexpect  | struct           | void     |
| char32_t   | export       |  nullptr  | switch           | volatile |
| class      | extern       | operator  | tempalte         | wchar_t  |
| const      | false        |  private  | this             | while    |
| constexpr  | float        | protected | thread_local     |          |
| const_cast | for          |  public   | throw            |          |

### 2.24 名字的作用域



## 2.3 符合类型

## 2.4 const限定符

## 2..5 处理类型

## 2.6 自定义数据结构